{
  "blocks": [
    {
      "type": "code",
      "output": "import {mut} from \"/lib/solid/monke.js\"\n\nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\ndefer(function() {\n  let E = M.EDITOR\n    console.log('editor',E)\n\tif (!E) return\n   E.state.save(\"editor/one.json\")\n}, 3500)\n\n// -------------\n// Solid Imports\n// -------------\nimport {\n\tbatch,\n\teach,\n\teff_on,\n\th,\n\tmem,\n\tmounted,\n\tproduce,\n\trender,\n\tsig,\n\tstore,\n} from \"/lib/solid/monke.js\";\n\nimport { Keymanager } from \"/lib/keymanager.js\";\nimport { createEnvironment } from \"/lib/ts/ts.js\";\n\n// -------------\n// Codemirror Imports\n// -------------\nimport {\n\tbasicSetup,\n\tEditorState,\n\tautocompletion, \n    toggleFold,\n    foldAll,\n\tlinter,\n\tEditorView,\n\tHighlightStyle,\n\tjavascript,\n\tkeymap,\n\tsyntaxHighlighting,\n\tt,\n\tcompleteFromList,\n\tVim,\n\tvim,\n} from \"/lib/codemirror/bundled.js\";\n\n// -------------\n// UTILITIES\n// -------------\n\nlet CURRENT_PATH = sig(\"\");\nconst m = () => { return iframe_ref()?.contentDocument.M }\n\n// -------------\nlet iframe_ref = sig(null)\n\neff_on(iframe_ref, () => {\n\tif (iframe_ref()) {\n\t\tconsole.log(\"ref was set\", iframe_ref())\n\t\tconsole.log(\"SETTING EDITOR\")\n\t\tif (m()) m().EDITOR = editor\n\t}\n})\n\n// -------------\n\nconst uid = () => Math.random().toString(36).substring(7);\n\nconst throttle = (fn, delay) => {\n\tlet timerFlag = null;\n\treturn (...args) => {\n\t\tif (timerFlag === null) {\n\t\t\tfn(...args);\n\t\t\ttimerFlag = setTimeout(() => timerFlag = null, delay);\n\t\t}\n\t};\n}\n\n\nfunction eval_code(code) {\n\treturn eval(`\"use strict\";(${code})`);\n}\n\n// =============\n// CORE\n// =============\nclass RendererList {\n\tconstructor() {\n\t\tconst [renderers, set_renderers] = store({});\n\t\tthis.renderers = renderers;\n\t\tthis.set_renderers = set_renderers;\n\t}\n\n\tregister(type, fn) {\n\t\tthis.set_renderers(type, fn);\n\t}\n\n\t/**\n\t * @param {name} string\n\t * @returns {() => View}\n\t */\n\tfind(type) {\n\t\tconst fn_str = this.renderers[type];\n\t\tconst fn = eval_code(fn_str);\n\t\tif (typeof fn == \"function\") return fn;\n\t\telse throw new Error(\"invalid renderer\");\n\t}\n}\n\nclass State {\n\tconstructor({ type, blocks, parent, cursor, id, tsserver }) {\n\t\tconst _blocks = blocks ? blocks : [];\n\t\tconst _type = type ? type : \"default\";\n\t\tconst _id = id ? id : uid();\n\n\t\tconst [model, update] = store({\n\t\t\tblocks: _blocks,\n\t\t\toutput: \"\",\n\t\t});\n\n\t\tthis.id = _id;\n\t\tthis.type = _type;\n\t\tthis.model = model;\n\t\tthis.tsserver = tsserver\n\t\tthis.update = (...args) => update(...args);\n\n\t\tthis.parent = parent;\n\t\tthis.cursor = sig(cursor || -1);\n\t}\n\n\tget blocks() {\n\t\treturn this.model.blocks;\n\t}\n\n\tupdate_blocks(...args) {\n\t\treturn this.update(\"blocks\", ...args);\n\t}\n\n\tlen() {\n\t\treturn this.model.blocks.length;\n\t}\n\n\tnext() {\n\t\tthis.len() > this.cursor() + 1\n\t\t\t? this.cursor.set(this.cursor() + 1)\n\t\t\t: this.cursor.set(0);\n\t}\n\n\tprev() {\n\t\tthis.cursor() > 0\n\t\t\t? this.cursor.set(this.cursor() - 1)\n\t\t\t: this.cursor.set(this.len() - 1);\n\t}\n\n\twrite() {\n\t\tconst queue = this.model.blocks.map((comp) => comp.write);\n\t\tlet start = 0\n\t\tconst run = (code, index) => {\n\t\t\tif (\"function\" == typeof code) {\n\t\t\t\tthis.update_blocks(index, produce((el) => {\n\t\t\t\t\tel.start = start\n\t\t\t\t\tcode(el)\n\t\t\t\t\tstart += el.output.length\n\t\t\t\t}))\n\t\t\t}\n\t\t}\n\n\t\tbatch(() => {\n\t\t\tqueue.forEach(run)\n\t\t});\n\n\t\tthis.output = this.model.blocks.map((e) => e.output).join(\"\");\n\t}\n\n\tasync lint(from, to) {\n\t\tif (!this.tsserver) { return this.parent.lint(from + this.start, to + this.start) }\n\n\t\tlet sem_diagnostics = await this.tsserver.semantic_diagnostics();\n\t\tlet syn_diagnostics = await this.tsserver.syntactic_diagnostics();\n\n\t\tif (!Array.isArray(sem_diagnostics)) sem_diagnostics = []\n\t\tif (!Array.isArray(syn_diagnostics)) syn_diagnostics = []\n\t\tconst diagnostics = [...sem_diagnostics, ...syn_diagnostics]\n\t\tif (!diagnostics) return []\n\n\t\treturn diagnostics\n\t\t\t.filter(d => d.start !== undefined && d.length !== undefined)\n\t\t\t.map(d => {\n\t\t\t\tif (d.code == 7006 || d.code == 7005) return\n\t\t\t\tlet severity = \"error\"\n\n\t\t\t\tlet f = d.start - from // if from < f, => f < 0 \n\t\t\t\tlet t = f + d.length\n\n\t\t\t\tif (f < 0) { return }\n\t\t\t\tif (d.start + d.length >= to) { return }\n\n\t\t\t\tlet message = d.messageText\n\n\t\t\t\treturn {\n\t\t\t\t\tfrom: f,\n\t\t\t\t\tto: t,\n\t\t\t\t\tseverity,\n\t\t\t\t\tmessage\n\t\t\t\t};\n\t\t\t}).filter((e) => e != undefined);\n\t};\n\n\tasync completion(pos, ctx) {\n\t\tif (!ctx) return null\n\t\tif (!this.tsserver) {\n\t\t\t// then send req to parent and add personal start\n\t\t\tconst c = this.parent.completion(pos + this.start, ctx)\n\t\t\treturn c\n\t\t}\n\n\t\tconst completions = await this.tsserver.completion_at(pos);\n\t\tif (!completions) { return null; }\n\n\t\tlet completList = completeFromList(\n\t\t\tcompletions.entries.map((c, _) => {\n\t\t\t\treturn {\n\t\t\t\t\ttype: c.kind,\n\t\t\t\t\tlabel: c.name,\n\t\t\t\t\tboost: 1 / parseInt(c.sortText),\n\t\t\t\t}\n\t\t\t})\n\t\t)(ctx)\n\n\t\treturn completList\n\t}\n\n\t// TODO: Localstorage and reload?\n\tload(path) {\n\t\tfetch(\"/fs/\" + path).then((res) => res.json())\n\t\t\t.then((res) => {\n\t\t\t\tres.blocks\n\t\t\t\t\t? this.update(\"blocks\", res.blocks)\n\t\t\t\t\t: console.log(\"no blocks\");\n\t\t\t\tCURRENT_PATH.set(path);\n\t\t\t});\n\t}\n\n\t// TODO: Implement saving functions in the editor itself -> next version\n\t// TODO: Make a component for file directory editing and saving stuff\n\toverwrite(path) {\n\t\tconsole.log(\"overwriting\", path);\n\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tcreate_new(path) {\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"POST\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tsave(path) {\n\t\tfetch(\"/exists/\" + path).then((res) => res.json()).then((res) =>\n\t\t\tres.exists ? this.overwrite(path) : this.create_new(path)\n\t\t);\n\t}\n\n\tpreview(path) {\n\t\t// fix this\n\t\tthis.output_file(path).then((res) => {\n\t\t\twindow.location = \"/fs/\" + path;\n\t\t});\n\t}\n\n\toutput_file(path) {\n\t\tconst body = {\n\t\t\tcontent: iframe(),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n}\n\nclass Tsserver {\n\tconstructor(file = \"\", browser = false) {\n\t\tthis.env = null\n\t\tthis.file = file\n\t\tthis.browser = browser\n\n\t\tif (this.browser) {\n\t\t\t//TODO: Turn into webworker later\n\t\t\tcreateEnvironment(\"console.log('hello world')\").then((e) => {\n\t\t\t\tthis.env = e;\n\t\t\t\t// add tsconfig.json\n\t\t\t\tthis.update_file(this.file)\n\t\t\t})\n\t\t}\n\t}\n\n\tupdate_file(content) {\n\t\tif (!content || content.length == 0) return\n\t\tlet space_only = true\n\t\tcontent.split(\"\").forEach((c) => { if (c != \" \") space_only = false })\n\t\tif (space_only) return\n\n\t\tif (this.browser) {\n\t\t\tif (this.env) { this.env.updateFile(\"index.js\", content) }\n\t\t\telse this.file = content\n\t\t}\n\n\t\tfetch(\"/tsserver/update\", {\n\t\t\tmethod: \"POST\", body: JSON.stringify({ content }),\n\t\t\theaders: { \"Content-Type\": \"application/json\" }\n\t\t})\n\n\t}\n\n\tasync completion_at(pos) {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getCompletionsAtPosition('index.js', pos)\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res =\n\t\t\t\tawait fetch(\"/tsserver/completion_at\", {\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tmethod: \"POST\", body: JSON.stringify({ pos })\n\t\t\t\t})\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync semantic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/semantic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t\t// if (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t// else return []\n\t}\n\n\tasync syntactic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSyntacticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/syntactic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t}\n\n\n}\n\n//TODO: make this part of the editor...\nclass Positioner {\n\tconstructor(x, y, w, h, unit = \"v\", position = \"fixed\") {\n\t\tthis.x = sig(x || 0);\n\t\tthis.y = sig(y || 0);\n\t\tthis.w = sig(w || 0);\n\t\tthis.h = sig(h || 0);\n\n\t\tthis.unit = unit;\n\t\tthis.position = position;\n\n\t\tthis.style = mem(() => {\n\t\t\tconst v = this.unit == \"v\" ? \"vh\" : this.unit;\n\t\t\tconst h = this.unit == \"v\" ? \"vw\" : this.unit;\n\n\t\t\treturn `\n\t\t\t\tposition: ${this.position};\n\t\t\t\ttop: ${this.y() + v};\n\t\t\t\tleft: ${this.x() + h};\n\t\t\t\theight: ${this.h() + v};\n\t\t\t\twidth: ${this.w() + h};\n\t\t\t`;\n\t\t});\n\t}\n\n\tget css() {\n\t\treturn this.style;\n\t}\n}\n\n// Pass Editor into M -> so the live code in editor can change stuff in this editor.\nclass Editor {\n\t/**\n\t * @param {Object} EditorOpts \n\t * @param {State} EditorOpts.state \n\t * */\n\tconstructor({ state, components, renderer }) {\n\t\tif (!renderer) throw Error(\"Need a renderer\");\n\t\tthis.tsserver = new Tsserver()\n\t\tif (state) state.tsserver = this.tsserver\n\t\tthis.state = state ? state : new State({ type: \"RootGroup\", tsserver: this.tsserver });\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderers = components ? components : new RendererList();\n\t\tthis.positioner = new Positioner(0, 0, 50, 100);\n\n\t\tthis.live_output = sig(null)\n\t\tthis.output = mem(() => this.state.model.blocks.map((b) => b.output || \"\").join(\"\") || \"\")\n\n\n\t\teff_on(this.output, () => { this.tsserver.update_file(this.output()) })\n\n\t\teff_on(this.live_output, () => {\n\t\t\tif (this.live_output() && this.live_output() != null) {\n\t\t\t\tlet out = this.live_output()\n\t\t\t\tthis.tsserver.update_file(out)\n\t\t\t}\n\t\t})\n\t}\n\n\tregister(type, fn_str) {\n\t\tthis.renderers.register(type, fn_str);\n\t}\n\n\tget css() {\n\t\treturn this.positioner.css\n\t}\n\n\tbind(element, setter) {\n\t\tconst render = this.renderer;\n\t\tconst component = render(element, this.state);\n\n\t\tsetter((el) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => el[key] = value);\n\t\t});\n\n\t\treturn component.render;\n\t}\n\n\trender() {\n\t\tconst setter = (fn) => this.state.update(produce(fn));\n\t\treturn this.bind(this.state, setter);\n\t}\n}\n\n//TODO: make these available at user runtime\nfunction state_utils(state) {\n  const find_focused = () => state.blocks.find((e) => e.focus);\n  const find_active = () => state.blocks.find((e) => e.active);\n  \n  function is_scrollable(el) {\n\treturn el.scrollHeight > el.clientHeight;\n  }\n \n  \n  function find_offset_to_parent(el, parent) {\n\treturn [el.offsetLeft - parent.offsetLeft, el.offsetTop - parent.offsetTop];\n  }\n\n  function get_scrollabe_parent(el) {\n  \tlet found_parent = false;\n  \tlet element = el;\n  \n  \tdo {\n  \t\telement = element.parentElement;\n  \n  \t\tif (!element) return;\n  \t\tif (is_scrollable(element)) found_parent = true;\n  \t} while (!found_parent && element);\n  \n  \treturn element;\n  }\n\n\n  const scroll_to_active = () => {\n    let active = find_active()\n    if (!active) return\n    let id = \"block-\"+active.id\n    \n    let el = document.getElementById(id);\n    let parent = get_scrollabe_parent(el);\n    if (parent) {\n        let [x, y] = find_offset_to_parent(el, parent);\n        parent.scrollTo({ top: y - 50, behavior: \"smooth\" });\n    }\n  }\n\n\n  const set_current_active = () => {\n      if (!state.blocks[state.cursor()]) return;\n      state.update_blocks(state.cursor(), \"active\", true);\n      state.update_blocks((_, i) => i != state.cursor(), \"active\", false);\n  };\n\n  const set_current_focus = () => {\n      if (!state.blocks[state.cursor()]) return;\n      const current = state.blocks[state.cursor()];\n      state.update_blocks(state.cursor(), \"focus\", true);\n      if (current.onfocus) current.onfocus();\n  };\n\n  const unfocus_current = () => {\n      const current = find_focused(state);\n      if (!current) return;\n      if (current.handle_unfocus) current.handle_unfocus()\n      else {\n          state.update_blocks((e) => e.focus, \"focus\", false);\n          if (current.onunfocus) current.onunfocus();\n      }\n  };\n\treturn {\n      find_focused,\n      scroll_to_active,\n      set_current_active,\n      set_current_focus,\n      unfocus_current,\n\t};\n}\n\nconst child_style = (child) => {\n\tconst border_is = mem(() => child.active && !child.focus);\n\tconst shadow_is = mem(() => child.focus);\n\n\tconst border = mem(() => border_is() ? \"border: .5px solid red\" : \"\");\n\tconst box_shadow = mem(() =>\n\t\tshadow_is() ? \"box-shadow: 0 0 25px 15px rgba(0,0,0,.1)\" : \"\"\n\t);\n\n\treturn mem(() => [border(), box_shadow()].join(\";\"));\n};\n\nconst add_widget = (opts, state) => {\n\tif (!opts.id) opts.id = uid()\n\tstate.update_blocks(produce((e) => e.push(opts)));\n\n\teditor.state.write()\n}\n\n// =============\n// Root Renderer\n// =============\n/**\n * @param {State} state\n */\nfunction RootRenderer(el, state) {\n\tif (!state) throw Error(\"NEED STATE\")\n\n\tconst blocks = el.blocks || [];\n\tstate = state || new State({ blocks });\n\n\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n      scroll_to_active\n\t} = state_utils(state);\n\n\teff_on(state.cursor, () => {\n      set_current_active()\n      scroll_to_active()\n      \n    });\n  // bring active in scroll\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style, id: \"block-\" + child.id }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Escape\", unfocus_current);\n\tkeys.on(\"Enter\", set_current_focus);\n\tkeys.on(\"shift+c\", (_) => add_widget({ type: \"code\" }, state));\n\tkeys.on(\"shift+a\", (_) => add_widget({ type: \"slider\" }, state));\n\tkeys.on(\"shift+g\", (_) => add_widget({ type: \"group\" }, state));\n\tkeys.on(\"shift+;\", () => {\n\t\tinput_ref.value = \":\";\n\t\tinput_ref.focus();\n\t});\n\t// keys.on(\"cmd+m\", (_) => state.save(save_path));\n\t// keys.on(\"cmd+l\", (_) => state.load(save_path));\n\t// keys.on(\"cmd+o\", (_) => state.output_file(\"output.html\"));\n\tkeys.on(\"cmd+e\", (_) => state.preview(\"output.html\"));\n\t// keys.on(\"cmd+b\", (_) => console.log(\"source\", CURRENT_PATH));\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\\n\");\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\n\t// ---------------\n\t// Input Bar\n\t// ---------------\n\tconst style = `\n\t\tall: unset;\n\t\tborder: .5px #eee solid;\n\t`;\n\n\tconst on_input = (e) => console.log(e.target.value);\n\tconst on_keydown = (e) =>\n\t\te.key == \"Escape\" ? (input_ref.blur(), input_ref.value = \"\") : null;\n\n\tlet input_ref = (e) => input_ref = e;\n\tconst input_bar = h(\"input\", {\n\t\tref: input_ref,\n\t\ttype: \"text\",\n\t\tstyle: style,\n\t\toninput: on_input,\n\t\tonkeydown: on_keydown,\n\t});\n\n\treturn {\n\t\trender: () =>\n\t\t\th(\"div.group\", () => each(() => state.blocks, bind), input_bar),\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t};\n}\n\n\nconst state = new State({\n\tblocks: [{\n\t\ttype: \"code\",\n\t\toutput:\n\t\t\t`import {mut} from \"/lib/solid/monke.js\"\n\nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\ndefer(function() {\n  let E = M.EDITOR\n\tif (!E) return\n  // E.state.load(\"utils/fileviewer.json\")\n})\n`}]\n})\n\nconst editor = new Editor({ renderer: RootRenderer, state });\n\n/**\n * @typedef {Object} View\n *\n * @property {(el) => void} write\n * @property {() => any[] | any} render\n *\n * @property {() => void} [onkeydown]\n * @property {() => void} [onfocus]\n * @property {() => void} [onunfocus]\n */\nwindow.onload = () => {\n\twindow.addEventListener(\"keydown\", (e) => {\n\t\tif (editor.state.model.onkeydown) {\n\t\t\teditor.state.model.onkeydown(e);\n\t\t}\n\t});\n};\n\n// Document as known issues\nconst f = \"/\";\nconst iframe = mem(() =>\n\t`<script type=\"module\"> \n        const SOURCE_PATH = \"${CURRENT_PATH()}\"\n        ${editor.state.blocks.map((e) => e.output).join(\"\\n\")}\n    <${f}script>`\n);\n\neff_on(iframe, () => defer(function() {\n\tconsole.log(\"Hey iframe was changed\")\n\tif (m()) m().EDITOR = editor\n}, 1500))\n\nconst Root = () => {\n\tconst iframe_pos = new Positioner(50, 0, 50, 100);\n\n\tconst iframe_style = iframe_pos.css;\n\tconst editor_style = mem(() => \"overflow-y: scroll;\" + editor.css());\n\n\treturn h(\"div\", [\n\t\th(\"div.editor\", { style: editor_style }, editor.render()),\n\t\th(\"iframe.iframe\", { ref: iframe_ref.set, srcdoc: iframe, style: iframe_style }),\n\t]);\n};\n\n// ------------------------\n// CODEMIRROR ELEMENT\n// ------------------------\nfunction code_element(state, index, control) {\n\tconst code = mem(() => state?.output ? state?.output : \"\");\n\n\t// only used for syncing with tsserver\n\tconst live_code = sig()\n\tconst id = uid();\n\tlet save, focus;\n\n\tVim.defineEx(\"write\", \"w\", () => editor.state.write());\n\n\tconst live_output = mem(() => {\n\t\tif (state.focus) {\n\t\t\tlet code_map = {}\n\t\t\tcode_map[state.id] = live_code()\n\t\t\t// console.log(\"codemap, state id\", code_map[state.id])\n\n\t\t\tconst get_state_code_and_map = (state, map) => {\n\t\t\t\tlet id = state.id\n\t\t\t\tlet code = state.blocks\n\t\t\t\t\t.map((block) => map[block.id]\n\t\t\t\t\t\t? map[block.id]\n\t\t\t\t\t\t: block.output\n\t\t\t\t\t\t\t? block.output\n\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t.join(\"\")\n\n\t\t\t\tmap[id] = code\n\t\t\t\treturn code\n\t\t\t}\n\n\t\t\tlet parent = control.state\n\t\t\tlet full_code = \"\"\n\n\t\t\t// check if control.state\n\t\t\twhile (parent) {\n\t\t\t\t// console.log('checknig', parent)\n\t\t\t\tfull_code = get_state_code_and_map(parent, code_map)\n\t\t\t\tparent = parent.parent\n\t\t\t}\n\n\t\t\treturn full_code\n\t\t}\n\t\telse return null\n\t})\n\n\teff_on(live_output, () => {\n\t\tif (live_output()) editor.live_output.set(live_output())\n\t\telse editor.live_output.set(null)\n\t})\n\n\t// codemirro on change extension\n\n\tconst render = () => {\n\t\tmounted(() => {\n\t\t\tlet extensions = [\n\t\t\t\tlinter(() => {\n\t\t\t\t\tlet start = state.start ? state.start : 0\n\t\t\t\t\tlet end = start + live_code().length\n\n\t\t\t\t\t// TODO: Change this to parent group state .lint -> and propogate start offset...\n\t\t\t\t\treturn control.state.lint(start, end)\n\t\t\t\t}),\n\n\t\t\t\tautocompletion({\n\t\t\t\t\tactivateOnTyping: true,\n\t\t\t\t\tmaxRenderedOptions: 20,\n\t\t\t\t\toverride: [async (ctx) => {\n\t\t\t\t\t\tlet { pos } = ctx\n\t\t\t\t\t\tlet start = state.start ? state.start : 0\n\t\t\t\t\t\tlet completion = await control.state.completion(pos + start, ctx)\n\t\t\t\t\t\treturn completion\n\t\t\t\t\t}],\n\t\t\t\t}),\n\n\n\t\t\t\tEditorView.updateListener.of(throttle((e) => live_code.set(e.state.doc.toString() + \"\\n\"), 100))]\n\n\t\t\tconst cm_editor = make_code_mirror(code(), id, extensions);\n\t\t\tfocus = () => setTimeout(() => cm_editor.focus(), 100);\n\n\t\t\tsave = function(el) {\n\t\t\t\t// TODO: add \"\\n\" only when not already added... \n\t\t\t\t// TODO: Also mirro mechanism where else doc is accessed.\n\t\t\t\tconst text = cm_editor.state.doc.toString() + \"\\n\"\n\t\t\t\tconsole.log(\"text\", text, \"start\", el.start);\n\t\t\t\tel.focused = cm_editor.hasFocus;\n\t\t\t\tel.output = text;\n\t\t\t\tel.cursor = cm_editor.state.selection.ranges[0].from;\n\t\t\t};\n\n\t\t\tdefer(function() {\n\t\t\t\tif (state.cursor && state.focused) {\n\t\t\t\t\tconst selection = { anchor: state.cursor, head: state.cursor };\n\t\t\t\t\tcm_editor.focus();\n\t\t\t\t\tcm_editor.dispatch({ selection });\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn h(\"div\", { class: \"editor-\" + id });\n\t};\n\n\t// TODO: COMPONENT: template object representation\n\t// should have icons for things and have intellisense...\n\treturn ({\n\t\trender: render,\n\t\tonfocus: () => focus(),\n\t\twrite: (...args) => save(...args),\n\t});\n}\neditor.register(\"code\", code_element.toString());\n\n// ------------------------\n// SLIDER ELEMENT\n// ------------------------\nfunction slider(state){\n  let val = sig(state.value ? state.value : 0)\n  let output = mem(() => `M.slider = ${val()}`)\n  eff_on(val, () => {\n    console.log(\"sliding\", m(), val())\n    if (m()) m().slider = val() \n  })\n  \n  const renderer = () => {\n    return  h(\"div\", \n      h(\"input\", {\n      type: \"range\",\n      oninput: (e) => val.set(e.target.value)  }\n     ), h(\"p\", \"Value: \", val)\n    )\n  }\n\n  const write = (el) => {\n    el.output = output()\n    el.value = val()\n  }\n  \n  return {\n    render: renderer,\n    write: write\n  }\n}\neditor.register(\"slider\", slider.toString())\n\n\n// ------------------------\n// GROUP Renderer\n// ------------------------\n/**\n * @typedef {Object} Controller\n * @property {State} state\n *\n */\n\n/**\n * @param {Controller} c \n */\nfunction GroupRenderer(el, i, c,) {\n\t// new state\n\tlet state = new State({ blocks: el.blocks || [], parent: c.state, id: el.id })\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n\t} = state_utils(state);\n\n\teff_on(state.cursor, set_current_active);\n\n\tconst _unfocus = () => {\n\t\t// if none in focus unfocus self, else just forward to unfocus current\n\t\tlet focused = find_focused()\n\t\tif (!focused) c.set_self(\"focus\", false)\n\t\telse unfocus_current()\n\t}\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Enter\", set_current_focus);\n\tkeys.on(\"shift+c\", (_) => add_widget({ type: \"code\" }, state));\n\tkeys.on(\"shift+g\", (_) => add_widget({ type: \"group\" }, state));\n\tkeys.on(\"shift+a\", (_) => add_widget({ type: \"basic\" }, state));\n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\");\n\t\tconsole.log('Group starts at: ', el.start)\n\t\t//TODO : FUCKING FIX THIS\n\t\tstate.start = el.start\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\n\treturn {\n\t\trender: () =>\n\t\t\th(\"div.group\", () => each(() => state.blocks, bind)),\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t\thandle_unfocus: _unfocus,\n\t};\n}\n\neditor.register(\"group\", GroupRenderer.toString())\n\n//\n// ------------------------\n// CODEMIRROR UTILS\n// ------------------------\nfunction make_code_mirror(source, id, extensions) {\n\tconst element = document.querySelector(\".editor-\" + id);\n\tconst state = {\n\t\tdoc: source,\n\t\textensions: [\n\t\t\tvim(),\n\t\t\tbasicSetup,\n\t\t\tjavascript(),\n\t\t\ttheme,\n\t\t\t...extensions,\n\n\t\t\tkeymap.of([\n                {\n                  key: \"Mod-e\",\n                  run: () =>  toggleFold(editor)\n                },\n              \n                {\n                  key: \"Mod-shift-e\",\n                  run: () =>  foldAll(editor)\n                },\n\t\t\t\t{\n\t\t\t\t\tkey: \"Escape\",\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\teditor.contentDOM.blur();\n\t\t\t\t\t\twindow.getSelection()?.removeAllRanges();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]),\n\t\t],\n\t};\n\n\tconst editor = new EditorView({\n\t\tparent: element,\n\t\tstate: EditorState.create(state),\n\t});\n\n\treturn editor;\n}\n\n\nconst createTheme = ({ variant, settings, styles }) => {\n\tconst theme = EditorView.theme(\n\t\t{\n\t\t\t// eslint-disable-next-line @typescript-eslint/naming-convention\n\t\t\t\"&\": {\n\t\t\t\tbackgroundColor: settings.background,\n\t\t\t\tcolor: settings.foreground,\n\t\t\t},\n\t\t\t\".cm-editor.cm-focused\": {\n\t\t\t\toutline: \"none\",\n\t\t\t},\n\t\t\t\".cm-content\": {\n\t\t\t\tcaretColor: settings.caret,\n\t\t\t},\n\t\t\t\".cm-cursor, .cm-dropCursor\": {\n\t\t\t\tborderLeft: \"2px solid\" + settings.caret,\n\t\t\t},\n\t\t\t\"&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection\":\n\t\t\t{\n\t\t\t\tbackgroundColor: settings.selection,\n\t\t\t},\n\t\t\t\".cm-activeLine\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t\t\".cm-gutters\": {\n\t\t\t\tbackgroundColor: settings.gutterBackground,\n\t\t\t\tcolor: settings.gutterForeground,\n\t\t\t},\n\t\t\t\".cm-activeLineGutter\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdark: variant === \"dark\",\n\t\t},\n\t);\n\n\tconst highlightStyle = HighlightStyle.define(styles);\n\tconst extension = [theme, syntaxHighlighting(highlightStyle)];\n\n\treturn extension;\n};\n\nconst theme = createTheme({\n\tvariant: \"dark\",\n\tsettings: {\n\t\tbackground: \"#44d\",\n\t\tforeground: \"white\",\n\t\tcaret: \"yellow\",\n\t\tselection: \"#036dd626\",\n\t\tgutterBackground: \"#fcfcfc22\",\n\t\tgutterForeground: \"#8a919922\",\n\t\tlineHighlight: \"#8a919922\",\n\t},\n\tstyles: [\n\t\t{\n\t\t\ttag: t.comment,\n\t\t\tcolor: \"#ffffff44\",\n\t\t},\n\t\t{\n\t\t\ttag: t.string,\n\t\t\tcolor: \"#00ffee\",\n\t\t},\n\t\t{\n\t\t\ttag: t.regexp,\n\t\t\tcolor: \"#4cbf99\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.number, t.bool, t.null],\n\t\t\tcolor: \"aaf\",\n\t\t},\n\t\t{\n\t\t\ttag: t.variableName,\n\t\t\tcolor: \"beige\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.definitionKeyword, t.modifier],\n\t\t\tcolor: \"#EEED95\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.keyword, t.special(t.brace)],\n\t\t\tcolor: \"#EEED95\",\n\t\t},\n\t\t{\n\t\t\ttag: t.operator,\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t\t{\n\t\t\ttag: t.separator,\n\t\t\tcolor: \"#5c6166b3\",\n\t\t},\n\t\t{\n\t\t\ttag: t.punctuation,\n\t\t\tcolor: \"#EEED95\",\n\t\t\tboxShadow: \"0 0 2px 1px #EEED9566\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.definition(t.propertyName), t.function(t.variableName)],\n\t\t\tcolor: \"yellow\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.className, t.definition(t.typeName)],\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.tagName, t.typeName, t.self, t.labelName],\n\t\t\tcolor: \"#55b4d4\",\n\t\t},\n\t\t{\n\t\t\ttag: t.angleBracket,\n\t\t\tcolor: \"#55b4d480\",\n\t\t},\n\t\t{\n\t\t\ttag: t.attributeName,\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t],\n});\n\nrender(Root, document.body);\n\n\n\n\n",
      "active": true,
      "focus": true,
      "start": 0,
      "focused": false,
      "cursor": 23363
    },
    {
      "type": "slider",
      "id": "51j61p",
      "start": 25769,
      "output": "M.slider = 42",
      "value": "42",
      "active": false,
      "focus": false
    }
  ],
  "output": ""
}