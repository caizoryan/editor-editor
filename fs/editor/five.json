{
  "blocks": [
    {
      "type": "code",
      "output": "import {mut} from \"/lib/solid/monke.js\"\n    \nconst BACKGROUND = \"beige\"\nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\n// -------------\n// Solid Imports\n// -------------\nimport {\n\tbatch,\n\teach,\n\teff_on,\n\th,\n  \tmem,\n\tmounted,\n\tproduce,\n\trender,\n\tsig,\n\tstore,\n} from \"/lib/solid/monke.js\";\n\nimport { Keymanager } from \"/lib/keymanager.js\";\nimport { createEnvironment } from \"/lib/ts/ts.js\";\n\n// -------------\n// Codemirror Imports\n// -------------\nimport * as cm from \"/lib/codemirror/codemirror.js\"\nconst {basicSetup,EditorView, Vim, vim} = cm\nconst { indentWithTab } = cm.commands\nconst { EditorState, StateField } = cm.state\nconst { keymap, showTooltip } = cm.view\nconst { toggleFold, foldAll,   HighlightStyle, syntaxHighlighting,  } = cm.language\nconst { javascript } = cm.lang_javascript\nconst { tags } = cm.lezer_higlight\nconst { lintGutter, linter, openLintPanel } = cm.lint\nconst { autocompletion, completeFromList } = cm.autocomplete\nlet t = tags\n\n// -------------\n// UTILITIES\n// -------------\n\nlet CURRENT_PATH = sig(\"\");\nconst m = () => { return iframe_ref()?.contentDocument.M }\n\n// -------------\nlet iframe_ref = sig(null)\n\neff_on(iframe_ref, () => {\n\tif (iframe_ref()) {\n\t\tconsole.log(\"ref was set\", iframe_ref())\n\t\tconsole.log(\"SETTING EDITOR\")\n\t\tif (m()) m().EDITOR = editor\n\t}\n})\n\n// -------------\n\nconst uid = () => Math.random().toString(36).substring(7);\n\nconst throttle = (fn, delay) => {\n  \n\tlet timerFlag = null;\n\treturn (...args) => {\n\t\tif (timerFlag === null) {\n\t\t\tfn(...args);\n\t\t\ttimerFlag = setTimeout(() => timerFlag = null, delay);\n\t\t}\n\t};\n}\nfunction eval_code(code) {\n\treturn eval(`\"use strict\";(${code})`);\n}\n\n// =============\n// CORE\n// =============\nclass RendererList {\n\tconstructor() {\n\t\tconst [renderers, set_renderers] = store({});\n\t\tthis.renderers = renderers;\n\t\tthis.set_renderers = set_renderers;\n\t}\n\n\tregister(type, fn) {\n\t\tthis.set_renderers(type, fn);\n\t}\n\n\t/**\n\t * @param {name} string\n\t * @returns {() => View}\n\t */\n\tfind(type) {\n\t\tconst fn_str = this.renderers[type];\n\t\tconst fn = eval_code(fn_str);\n\t\tif (typeof fn == \"function\") return fn;\n\t\telse throw new Error(\"invalid renderer\");\n\t}\n}\n\nclass State {\n\tconstructor({ type, blocks, parent, cursor, id, tsserver }) {\n\t\tconst _blocks = blocks ? blocks : [];\n\t\tconst _type = type ? type : \"default\";\n\t\tconst _id = id ? id : uid();\n\n\t\tconst [model, update] = store({\n\t\t\tblocks: _blocks,\n\t\t\toutput: \"\",\n\t\t});\n\n\t\tthis.id = _id;\n\t\tthis.type = _type;\n\t\tthis.model = model;\n\t\tthis.tsserver = tsserver\n\t\tthis.update = (...args) => update(...args);\n\n\t\tthis.parent = parent;\n\t\tthis.cursor = sig(cursor || -1);\n\t}\n\n\tget blocks() {\n\t\treturn this.model.blocks;\n\t}\n\n\tupdate_blocks(...args) {\n\t\treturn this.update(\"blocks\", ...args);\n\t}\n\n\tlen() {\n\t\treturn this.model.blocks.length;\n\t}\n\n\tnext() {\n\t\tthis.len() > this.cursor() + 1\n\t\t\t? this.cursor.set(this.cursor() + 1)\n\t\t\t: this.cursor.set(0);\n\t}\n\n\tprev() {\n\t\tthis.cursor() > 0\n\t\t\t? this.cursor.set(this.cursor() - 1)\n\t\t\t: this.cursor.set(this.len() - 1);\n\t}\n\n\twrite() {\n\t\tconst queue = this.model.blocks.map((comp) => comp.write);\n\t\tlet start = 0\n\t\tconst run = (code, index) => {\n\t\t\tif (\"function\" == typeof code) {\n\t\t\t\tthis.update_blocks(index, produce((el) => {\n\t\t\t\t\tel.start = start\n\t\t\t\t\tcode(el)\n\t\t\t\t\tstart += el.output.length\n\t\t\t\t}))\n\t\t\t}\n\t\t}\n\n\t\tbatch(() => {\n\t\t\tqueue.forEach(run)\n\t\t});\n\n\t\tthis.output = this.model.blocks.map((e) => e.output).join(\"\");\n\t}\n\n\tasync lint(from, to) {\n      if (!this.tsserver) { return this.parent.lint(from + this.start, to + this.start) }\n\n      let sem_diagnostics = await this.tsserver.semantic_diagnostics();\n      let syn_diagnostics = await this.tsserver.syntactic_diagnostics();\n\n      if (!Array.isArray(sem_diagnostics)) sem_diagnostics = []\n      if (!Array.isArray(syn_diagnostics)) syn_diagnostics = []\n      const diagnostics = [...sem_diagnostics, ...syn_diagnostics]\n      if (!diagnostics) return []\n\n      return diagnostics\n          .filter(d => d.start !== undefined && d.length !== undefined)\n          .map(d => {\n              if (d.code == 7006 || d.code == 7005) return\n              let severity = \"error\"\n\n              let f = d.start - from // if from < f, => f < 0 \n              let t = f + d.length\n\n              if (f < 0) { return }\n              if (d.start + d.length >= to) { return }\n\n              let message = d.messageText\n              console.log(\"message: \", message)\n\n              return {\n                  from: f,\n                  to: t,\n                  severity,\n                  message\n              };\n          }).filter((e) => e != undefined);\n\t};\n\n\tasync completion(pos, ctx) {\n\t\tif (!ctx) return null\n\t\tif (!this.tsserver) {\n\t\t\t// then send req to parent and add personal start\n\t\t\tconst c = this.parent.completion(pos + this.start, ctx)\n\t\t\treturn c\n\t\t}\n\n\t\tconst completions = await this.tsserver.completion_at(pos);\n\t\tif (!completions) { return null; }\n\n\t\tlet completList = completeFromList(\n\t\t\tcompletions.entries.map((c, _) => {\n\t\t\t\treturn {\n\t\t\t\t\ttype: c.kind,\n\t\t\t\t\tlabel: c.name,\n\t\t\t\t\tboost: 1 / parseInt(c.sortText),\n\t\t\t\t}\n\t\t\t})\n\t\t)(ctx)\n\n\t\treturn completList\n\t}\n\n\t// TODO: Localstorage and reload?\n\tload(path) {\n\t\tfetch(\"/fs/\" + path).then((res) => res.json())\n\t\t\t.then((res) => {\n\t\t\t\tres.blocks\n\t\t\t\t\t? this.update(\"blocks\", res.blocks)\n\t\t\t\t\t: console.log(\"no blocks\");\n\t\t\t\tCURRENT_PATH.set(path);\n\t\t\t});\n\t}\n\n\t// TODO: Implement saving functions in the editor itself -> next version\n\t// TODO: Make a component for file directory editing and saving stuff\n\toverwrite(path) {\n\t\tconsole.log(\"overwriting\", path);\n\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tcreate_new(path) {\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"POST\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tsave(path) {\n\t\tfetch(\"/exists/\" + path).then((res) => res.json()).then((res) =>\n\t\t\tres.exists ? this.overwrite(path) : this.create_new(path)\n\t\t);\n\t}\n\n\tpreview(path) {\n\t\t// fix this\n\t\tthis.output_file(path).then((res) => {\n\t\t\twindow.location = \"/fs/\" + path;\n\t\t});\n\t}\n\n\toutput_file(path) {\n\t\tconst body = {\n\t\t\tcontent: iframe(),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n}\n\nclass Tsserver {\n\tconstructor(file = \"\", browser = false) {\n\t\tthis.env = null\n\t\tthis.file = file\n\t\tthis.browser = browser\n\n\t\tif (this.browser) {\n\t\t\t//TODO: Turn into webworker later\n\t\t\tcreateEnvironment(\"console.log('hello world')\").then((e) => {\n\t\t\t\tthis.env = e;\n\t\t\t\t// add tsconfig.json\n\t\t\t\tthis.update_file(this.file)\n\t\t\t})\n\t\t}\n\t}\n\n\tupdate_file(content) {\n\t\tif (!content || content.length == 0) return\n\t\tlet space_only = true\n\t\tcontent.split(\"\").forEach((c) => { if (c != \" \") space_only = false })\n\t\tif (space_only) return\n\n\t\tif (this.browser) {\n\t\t\tif (this.env) { this.env.updateFile(\"index.js\", content) }\n\t\t\telse this.file = content\n\t\t}\n\n\t\tfetch(\"/tsserver/update\", {\n\t\t\tmethod: \"POST\", body: JSON.stringify({ content }),\n\t\t\theaders: { \"Content-Type\": \"application/json\" }\n\t\t})\n\n\t}\n\n\tasync completion_at(pos) {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getCompletionsAtPosition('index.js', pos)\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res =\n\t\t\t\tawait fetch(\"/tsserver/completion_at\", {\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tmethod: \"POST\", body: JSON.stringify({ pos })\n\t\t\t\t})\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync semantic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/semantic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t\t// if (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t// else return []\n\t}\n\n\tasync syntactic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSyntacticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/syntactic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t}\n\n\n}\n\n//TODO: make this part of the editor...\nclass Positioner {\n\tconstructor(x, y, w, h, unit = \"v\", position = \"fixed\") {\n\t\tthis.x = sig(x || 0);\n\t\tthis.y = sig(y || 0);\n\t\tthis.w = sig(w || 0);\n\t\tthis.h = sig(h || 0);\n\n\t\tthis.unit = unit;\n\t\tthis.position = position;\n\n\t\tthis.style = mem(() => {\n\t\t\tconst v = this.unit == \"v\" ? \"vh\" : this.unit;\n\t\t\tconst h = this.unit == \"v\" ? \"vw\" : this.unit;\n\n\t\t\treturn `\n\t\t\t\tposition: ${this.position};\n\t\t\t\ttop: ${this.y() + v};\n\t\t\t\tleft: ${this.x() + h};\n\t\t\t\theight: ${this.h() + v};\n\t\t\t\twidth: ${this.w() + h};\n\t\t\t`;\n\t\t});\n\t}\n\n\tget css() {\n\t\treturn this.style;\n\t}\n}\n\n// Pass Editor into M -> so the live code in editor can change stuff in this editor.\nclass Editor {\n\t/**\n\t * @param {Object} EditorOpts \n\t * @param {State} EditorOpts.state \n\t * */\n\tconstructor({ state, components, renderer }) {\n\t\tif (!renderer) throw Error(\"Need a renderer\");\n\t\tthis.tsserver = new Tsserver()\n\t\tif (state) state.tsserver = this.tsserver\n\t\tthis.state = state ? state : new State({ type: \"RootGroup\", tsserver: this.tsserver });\n        this.iframe_pos = new Positioner(50, 0, 50, 100);\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderers = components ? components : new RendererList();\n\t\tthis.positioner = new Positioner(0, 0, 50, 100);\n\n\t\tthis.live_output = sig(null)\n\t\tthis.output = mem(() => this.state.model.blocks.map((b) => b.output || \"\").join(\"\") || \"\")\n\n\n\t\teff_on(this.output, () => { this.tsserver.update_file(this.output()) })\n\n\t\teff_on(this.live_output, () => {\n\t\t\tif (this.live_output() && this.live_output() != null) {\n\t\t\t\tlet out = this.live_output()\n\t\t\t\tthis.tsserver.update_file(out)\n\t\t\t}\n\t\t})\n\t}\n\n\tregister(type, fn_str) {\n\t\tthis.renderers.register(type, fn_str);\n\t}\n\n\tget css() {\n\t\treturn this.positioner.css\n\t}\n\n\tbind(element, setter) {\n\t\tconst render = this.renderer;\n\t\tconst component = render(element, this.state);\n\n\t\tsetter((el) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => el[key] = value);\n\t\t});\n\n\t\treturn component.render;\n\t}\n\n\trender() {\n\t\tconst setter = (fn) => this.state.update(produce(fn));\n\t\treturn this.bind(this.state, setter);\n\t}\n}\n\n//TODO: make these available at user runtime\nfunction state_utils(state) {\n  const find_focused = () => state.blocks.find((e) => e.focus);\n  const find_active = () => state.blocks.find((e) => e.active);\n  \n  function is_scrollable(el) {\n\treturn el.scrollHeight > el.clientHeight;\n  }\n \n  \n  function find_offset_to_parent(el, parent) {\n\treturn [el.offsetLeft - parent.offsetLeft, el.offsetTop - parent.offsetTop];\n  }\n\n  function get_scrollabe_parent(el) {\n  \tlet found_parent = false;\n  \tlet element = el;\n  \n  \tdo {\n  \t\telement = element.parentElement;\n  \n  \t\tif (!element) return;\n  \t\tif (is_scrollable(element)) found_parent = true;\n  \t} while (!found_parent && element);\n  \n  \treturn element;\n  }\n\n\n  const scroll_to_active = () => {\n    let active = find_active()\n    if (!active) return\n    let id = \"block-\"+active.id\n    \n    let el = document.getElementById(id);\n    let parent = get_scrollabe_parent(el);\n    if (parent) {\n        let [x, y] = find_offset_to_parent(el, parent);\n        parent.scrollTo({ top: y - 50, behavior: \"smooth\" });\n    }\n  }\n\n\n  const set_current_active = () => {\n      if (!state.blocks[state.cursor()]) return;\n      state.update_blocks(state.cursor(), \"active\", true);\n      state.update_blocks((_, i) => i != state.cursor(), \"active\", false);\n  };\n\n  const set_current_focus = () => {\n      if (!state.blocks[state.cursor()]) return;\n      const current = state.blocks[state.cursor()];\n      state.update_blocks(state.cursor(), \"focus\", true);\n      if (current.onfocus) current.onfocus();\n  };\n\n  const unfocus_current = () => {\n      const current = find_focused(state);\n      if (!current) return;\n      if (current.handle_unfocus) current.handle_unfocus()\n      else {\n          state.update_blocks((e) => e.focus, \"focus\", false);\n          if (current.onunfocus) current.onunfocus();\n      }\n  };\n\treturn {\n      find_focused,\n      scroll_to_active,\n      set_current_active,\n      set_current_focus,\n      unfocus_current,\n\t};\n}\n\nconst child_style = (child) => {\n\tconst border_is = mem(() => child.active && !child.focus);\n\tconst shadow_is = mem(() => child.focus);\n\n\tconst border = mem(() => border_is() ? \"border: .5px solid red\" : \"\");\n\tconst box_shadow = mem(() =>\n\t\tshadow_is() ? \"box-shadow: 0 0 25px 15px rgba(0,0,0,.1)\" : \"\"\n\t);\n\n\treturn mem(() => [border(), box_shadow()].join(\";\"));\n};\n\nconst add_widget = (opts, state) => {\n\tif (!opts.id) opts.id = uid()\n\tstate.update_blocks(produce((e) => e.push(opts)));\n\n\teditor.state.write()\n}\n\n// =============\n// Root Renderer\n// =============\n/**\n * @param {State} state\n */\nfunction RootRenderer(el, state) {\n\tif (!state) throw Error(\"NEED STATE\")\n\n\tconst blocks = el.blocks || [];\n\tstate = state || new State({ blocks });\n\n\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n      scroll_to_active\n\t} = state_utils(state);\n\n\teff_on(state.cursor, () => {\n      set_current_active()\n      scroll_to_active()\n      \n    });\n  // bring active in scroll\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div.child\", { style: style, id: \"block-\" + child.id }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Escape\", unfocus_current);\n\tkeys.on(\"Enter\", set_current_focus);\n\tkeys.on(\"shift+c\", (_) => add_widget({ type: \"code\" }, state));\n\tkeys.on(\"shift+s\", (_) => add_widget({ type: \"save-component\" }, state));\n\tkeys.on(\"shift+p\", (_) => add_widget({ type: \"editor_sizer\" }, state));\n\tkeys.on(\"shift+l\", (_) => add_widget({ type: \"load-component\" }, state));\n\tkeys.on(\"shift+g\", (_) => add_widget({ type: \"group\" }, state));\n\tkeys.on(\"shift+;\", () => {\n\t\tinput_ref.value = \":\";\n\t\tinput_ref.focus();\n\t});\n\t// keys.on(\"cmd+m\", (_) => state.save(save_path));\n\t// keys.on(\"cmd+l\", (_) => state.load(save_path));\n\t// keys.on(\"cmd+o\", (_) => state.output_file(\"output.html\"));\n\tkeys.on(\"cmd+e\", (_) => state.preview(\"output.html\"));\n\t// keys.on(\"cmd+b\", (_) => console.log(\"source\", CURRENT_PATH));\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\\n\");\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\n\t// ---------------\n\t// Input Bar\n\t// ---------------\n\tconst style = `\n\t\tall: unset;\n\t\tborder: .5px #eee solid;\n\t`;\n\n\tconst on_input = (e) => console.log(e.target.value);\n\tconst on_keydown = (e) =>\n\t\te.key == \"Escape\" ? (input_ref.blur(), input_ref.value = \"\") : null;\n\n\tlet input_ref = (e) => input_ref = e;\n\tconst input_bar = h(\"input\", {\n\t\tref: input_ref,\n\t\ttype: \"text\",\n\t\tstyle: style,\n\t\toninput: on_input,\n\t\tonkeydown: on_keydown,\n\t});\n\n\treturn {\n\t\trender: () =>\n\t\t\th(\"div.group\", () => each(() => state.blocks, bind), input_bar),\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t};\n}\n\n\nconst state = new State({\n\tblocks: [{\n\t\ttype: \"code\",\n\t\toutput:\n\t\t\t`import {mut} from \"/lib/solid/monke.js\"\n\nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\ndefer(function() {\n  let E = M.EDITOR\n\tif (!E) return\n  // E.state.load(\"utils/fileviewer.json\")\n})\n`}]\n})\n\nconst editor = new Editor({ renderer: RootRenderer, state });\n\n/**\n * @typedef {Object} View\n *\n * @property {(el) => void} write\n * @property {() => any[] | any} render\n *\n * @property {() => void} [onkeydown]\n * @property {() => void} [onfocus]\n * @property {() => void} [onunfocus]\n */\nwindow.onload = () => {\n\twindow.addEventListener(\"keydown\", (e) => {\n\t\tif (editor.state.model.onkeydown) {\n\t\t\teditor.state.model.onkeydown(e);\n\t\t}\n\t});\n};\n\n// Document as known issues\nconst f = \"/\";\nconst iframe = mem(() =>\n\t`<script type=\"module\"> \n        const SOURCE_PATH = \"${CURRENT_PATH()}\"\n        ${editor.state.blocks.map((e) => e.output).join(\"\\n\")}\n    <${f}script>`\n);\n\neff_on(iframe, () => defer(function() {\n\tconsole.log(\"Hey iframe was changed\")\n\tif (m()) m().EDITOR = editor\n}, 1500))\n\nconst Root = () => {\n\tconst iframe_style = editor.iframe_pos.css;\n\tconst editor_style = mem(() => \"overflow-y: scroll;\" + editor.css());\n    const style = `\n      html {\n        font-size: 14.5px;\n      }\n      ::-webkit-scrollbar {display: none;}\n      @font-face {\n\t\tfont-family: 'DiatypeMono';\n\t\tsrc: url('/fs/fonts/diatype_mono.ttf') format('truetype');\n    \t}\n\n      \n      * {\n        -ms-overflow-style: none;  /* IE and Edge */\n        scrollbar-width: none;  /* Firefox */\n        font-family: \"DiatypeMono\";\n      }\n\n      .child {\n        max-height: 95vh;\n        overflow-y: scroll;\n      }\n\n      input[type=\"text\"] {\n        all: unset;\n        border: 1px white solid;\n      }\n      \n      button {\n        all: unset;\n        cursor: pointer;\n        padding: 2px;\n        font-size: .8em;\n        color: white;\n        border: 1px white solid;\n      }\n      \n      iframe {\n        all: unset;\n      }\n      \n      body {\n\t\tbackground:${BACKGROUND};\n      }\n      \n      .group {\n        padding: 10px;\n      }\n    `\n\n\treturn h(\"div\", [\n        h(\"style\", style),\n\t\th(\"div.editor\", { style: editor_style }, editor.render()),\n\t\th(\"iframe.iframe\", { ref: iframe_ref.set, srcdoc: iframe, style: iframe_style }),\n\t]);\n};\n\n\n// ------------------------\n// SLIDER ELEMENT\n// ------------------------\nfunction slider(state){\n  let val = sig(state.value ? state.value : 0)\n  let output = mem(() => `M.slider = ${val()};`)\n  eff_on(val, () => {\n    console.log(\"sliding\", m(), val())\n    if (m()) m().slider = val() \n  })\n  \n  const renderer = () => {\n    return  h(\"div\", \n      h(\"input\", {\n        type: \"range\",\n        oninput: (e) => val.set(e.target.value)  }\n     ), h(\"p\", \"Value: \", val)\n    )\n  }\n\n  const write = (el) => {\n    el.output = output()\n    el.value = val()\n  }\n  \n  return {\n    render: renderer,\n    write: write\n  }\n}\neditor.register(\"slider\", slider.toString())\n\n// -----------------------\n// SAVE ELEMENT\n// ------------------------\nfunction save_editor(state) {\n  let path = sig(state.path ? state.path : \"\")\n  let save = () => editor.state.save(path())\n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                oninput: (e) => path.set(e.target.value)}),\n    h(\"button\",{onclick: save}, \"OVERWRITE\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.path = path();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\neditor.register(\"save-component\", save_editor.toString())\n  \n// -----------------------\n// LOAD ELEMENT\n// ------------------------\nfunction load_editor(state) {\n  console.log(\"path: \", state.path)\n  let path = sig(state.path ? state.path : \"\")\n  let load = () => editor.state.load(path())\n  let onkeydown = (e) => e.key == \"Enter\" ? load() : null\n  \n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                onkeydown: onkeydown,\n                oninput: (e) => path.set(e.target.value)}),\n    \n    h(\"button\",{onclick: load}, \"load\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.path = path();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\n\neditor.register(\"load-component\", load_editor.toString())\n  \n// -----------------------\n// Editor Sizer\n// ------------------------\nfunction editor_sizer(state) {\n  let size = sig(state.size ? state.size : \"50\")\n  let set_size = eff_on(size,() => {\n    if (size() < 20) return\n    let e_w = parseInt(size())\n    editor.positioner.w.set(e_w)\n    editor.iframe_pos.x.set(e_w)\n    editor.iframe_pos.w.set(100-e_w)\n  })\n  \n  const renderer = () => h(\"div\", [\n    \n    h(\"input\", {type: \"range\",\n                id: \"input-\"+state.id,\n                value: size,\n                oninput: (e) => size.set(e.target.value)}),\n    h(\"p\", \"Size: \", size, \"vw\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.size = size();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\n\neditor.register(\"editor_sizer\", editor_sizer.toString())\n\n\n\n// ------------------------\n// GROUP Renderer\n// ------------------------\n/**\n * @typedef {Object} Controller\n * @property {State} state\n *\n */\n\n/**\n * @param {Controller} c \n */\nfunction GroupRenderer(el, i, c,) {\n\t// new state\n\tlet state = new State({ blocks: el.blocks || [], parent: c.state, id: el.id })\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n\t} = state_utils(state);\n\n\teff_on(state.cursor, set_current_active);\n\n\tconst _unfocus = () => {\n\t\t// if none in focus unfocus self, else just forward to unfocus current\n\t\tlet focused = find_focused()\n\t\tif (!focused) c.set_self(\"focus\", false)\n\t\telse unfocus_current()\n\t}\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Enter\"     , set_current_focus);\n  \n\tkeys.on(\"J\"         , (_)=>state.next());\n\tkeys.on(\"K\"         , (_)=>state.prev());\n  \n\tkeys.on(\"SHIFT + C\" , (_)=>add_widget({ type: \"code\" }, state));\n\tkeys.on(\"SHIFT + G\" , (_)=>add_widget({ type: \"group\" }, state));\n\tkeys.on(\"CTRL + S\"  , (_)=> state.write());\n\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\");\n\t\tconsole.log('Group starts at: ', el.start)\n\t\t//TODO : FUCKING FIX THIS\n\t\tstate.start = el.start\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\n\treturn {\n\t\trender: () =>\n\t\t\th(\"div.group\", () => each(() => state.blocks, bind)),\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t\thandle_unfocus: _unfocus,\n\t};\n}\n\neditor.register(\"group\", GroupRenderer.toString())\n\n\n",
      "active": false,
      "focus": false,
      "start": 0,
      "focused": false,
      "cursor": 0
    },
    {
      "type": "code",
      "id": "t0gxe9",
      "start": 23855,
      "focused": false,
      "output": "\n// ------------------------\n// CODEMIRROR ELEMENT\n// ------------------------\nfunction code_element(state, index, control) {\n\tconst code = mem(() => state?.output ? state?.output : \"\");\n\n\t// only used for syncing with tsserver\n\tconst live_code = sig()\n\tconst id = uid();\n\tlet save, focus;\n\n\tVim.defineEx(\"write\", \"w\", () => editor.state.write());\n\tVim.defineEx(\"cm\", \"cm\", (e) => console.log(e));\n  /*\n  // to make zc and zm for folds\n  \n    Vim.defineAction(\"ArenaGoFile\", (cm) => {\n      console.log(\"ArenaGoFile\", cm);\n      \n      let [from, to] = [\n        view.state.selection.ranges[0].from,\n        view.state.selection.ranges[0].to,\n      ];\n      \n      let f = view.state.sliceDoc(from, to);\n      \n      if (link_is_block(f)) {\n        let block_id = extract_block_id(f);\n        window.location.href = host + \"/blocks/\" + block_id + offline;\n      }\n      console.log(from, to);\n      console.log(f);\n    });\n\n\n    Vim.mapCommand(\"gf\", \"action\", \"ArenaGoFile\", {}, { context: \"visual\" });\n  */\n\n\tconst live_output = mem(() => {\n\t\tif (state.focus) {\n\t\t\tlet code_map = {}\n\t\t\tcode_map[state.id] = live_code()\n\t\t\t// console.log(\"codemap, state id\", code_map[state.id])\n\n\t\t\tconst get_state_code_and_map = (state, map) => {\n\t\t\t\tlet id = state.id\n\t\t\t\tlet code = state.blocks\n\t\t\t\t\t.map((block) => map[block.id]\n\t\t\t\t\t\t? map[block.id]\n\t\t\t\t\t\t: block.output\n\t\t\t\t\t\t\t? block.output\n\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t.join(\"\")\n\n\t\t\t\tmap[id] = code\n\t\t\t\treturn code\n\t\t\t}\n\n\t\t\tlet parent = control.state\n\t\t\tlet full_code = \"\"\n\n\t\t\t// check if control.state\n\t\t\twhile (parent) {\n\t\t\t\t// console.log('checknig', parent)\n\t\t\t\tfull_code = get_state_code_and_map(parent, code_map)\n\t\t\t\tparent = parent.parent\n\t\t\t}\n\n\t\t\treturn full_code\n\t\t}\n\t\telse return null\n\t})\n\n\teff_on(live_output, () => {\n\t\tif (live_output()) editor.live_output.set(live_output())\n\t\telse editor.live_output.set(null)\n\t})\n\n\t// codemirro on change extension\n\n\tconst render = () => {\n      mounted(() => {\n\n       const cursorTooltipBaseTheme = EditorView.baseTheme({\n        \".cm-tooltip.cm-tooltip-cursor\": {\n          backgroundColor: \"#66b\",\n          color: \"white\",\n          border: \"none\",\n          padding: \"2px 7px\",\n          borderRadius: \"4px\",\n          \"& .cm-tooltip-arrow:before\": {\n            borderTopColor: \"#66b\"\n          },\n          \"& .cm-tooltip-arrow:after\": {\n            borderTopColor: \"transparent\"\n          }\n        }\n      }) \n      async function post(url = \"\", body) {\n        try {\n          let f = await fetch(url, {\n            method: \"POST\",\n            headers: {\"Content-Type\": \"application/json\"},\n            body: JSON.stringify(body)\n          }).then((res) => res.json())\n          return f\n        }catch {\n          return null\n        }\n      }\n\n\n      let def = sig(\"\")\n      let hover = sig(true)\n        \n      function get_cursor_tooltips (state)  {\n         return state.selection.ranges\n          .map(range => {\n            \n            let line = state.doc.lineAt(range.head)\n            \n                // *****************************\n                // TODO: Throttle this, runs too many times \n                // *****************************\n            \n            post(\"/ts/getQuickInfoAtPosition\", {args: [range.head]}).then(async (res) => {\n              console.log(\"res\", res)\n              if (res && res.displayParts){\n                let result = await post(\"/ts/displayPartsToString\", {args: [res.displayParts]})\n                let description = \"\"\n                res.documentation?.length \n                  ? description += await post(\"/ts/displayPartsToString\", {args: [res.documentation]})\n                  : null\n                def.set(result)\n              }\n            })\n            let text = line.number + \":\" + (range.head - line.from)\n            console.log(\"FUCKKKKK CALLLEDDD\")\n            return {\n              pos: range.head,\n              above: true,\n              strictSide: true,\n              arrow: true,\n              create: () => {\n                console.log(\"FUCKKK\")\n                let dom = document.createElement(\"div\")\n                \n                dom.className = \"cm-tooltip-cursor\"\n                dom.textContent = def()\n\n                // *****************************\n                // TODO: Manage disposing this, \n                // NOTE: this could spawn a lot of effects\n                // *****************************\n                \n                eff_on(def, () => dom.textContent = def())\n                eff_on(hover, () => dom.style.display = hover() ? \"\" : \"none\")\n                return { dom }\n              }\n            }\n          })[0]\n        \n      }\n      const cursorTooltipField = StateField.define({\n        create: get_cursor_tooltips,\n      \n        update: function(tooltips, tr) {\n          if (!tr.docChanged && !tr.selection) return tooltips\n          return get_cursor_tooltips(tr.state)\n        },\n        \n        provide: f => hover() ? showTooltip.compute([f], state => state.field(f)) : null\n      })\n\n      function tooltip () {return  [cursorTooltipField, cursorTooltipBaseTheme]}\n\n          let extensions = [\n              tooltip(),\n              linter(() => {\n                  let start = state.start ? state.start : 0\n                  let end = start + live_code().length\n                  return control.state.lint(start, end)\n              }),\n            \n              keymap.of([\n                  {\n                    key: \"Mod-Shift-i\",\n                    run: () =>  hover.set(!hover())\n                  },\n              ]),\n\n              autocompletion({\n                  activateOnTyping: true,\n                  maxRenderedOptions: 20,\n                  override: [async (ctx) => {\n                      let { pos } = ctx\n                      let start = state.start ? state.start : 0\n                      let completion = await control.state.completion(pos + start, ctx)\n                      return completion\n                  }],\n              }),\n\n              EditorView.updateListener.of(throttle((e) => live_code.set(e.state.doc.toString() + \"\\n\"), 100))]\n\n          const cm_editor = make_code_mirror(code(), id, extensions);\n          focus = () => setTimeout(() => cm_editor.focus(), 100);\n\n          save = function(el) {\n              // TODO: add \"\\n\" only when not already added... \n              // TODO: Also mirro mechanism where else doc is accessed.\n              const text = cm_editor.state.doc.toString() + \"\\n\"\n              console.log(\"text\", text, \"start\", el.start);\n              el.focused = cm_editor.hasFocus;\n              el.output = text;\n              el.cursor = cm_editor.state.selection.ranges[0].from;\n          };\n\n          defer(function() {\n              if (state.cursor && state.focused) {\n                  const selection = { anchor: state.cursor, head: state.cursor };\n                  cm_editor.focus();\n                  cm_editor.dispatch({ selection });\n              }\n          });\n      });\n\n\t\treturn h(\"div\", { class: \"editor-\" + id });\n\t};\n\n\t// TODO: COMPONENT: template object representation\n\t// should have icons for things and have intellisense...\n\treturn ({\n\t\trender: render,\n\t\tonfocus: () => focus(),\n\t\twrite: (...args) => save(...args),\n\t});\n}\neditor.register(\"code\", code_element.toString());\n\n// ------------------------\n// CODEMIRROR UTILS\n// ------------------------\nfunction make_code_mirror(source, id, extensions) {\n\tconst element = document.querySelector(\".editor-\" + id);\n\tconst state = {\n\t\tdoc: source,\n\t\textensions: [\n\t\t\tvim(),\n\t\t\tjavascript(),\n          \n\t\t\tbasicSetup,\n\t\t\ttheme,\n          \n\t\t\tkeymap.of([\n                indentWithTab,\n                {\n                  key: \"Mod-e\",\n                  run: () =>  toggleFold(editor)\n                },\n                {\n                  key: \"Mod-shift-e\",\n                  run: () =>  foldAll(editor)\n                },\n\t\t\t\t{\n\t\t\t\t\tkey: \"Escape\",\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\teditor.contentDOM.blur();\n\t\t\t\t\t\twindow.getSelection()?.removeAllRanges();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]),\n\t\t\t...extensions,\n\t\t],\n\t};\n\n\tconst editor = new EditorView({\n\t\tparent: element,\n\t\tstate: EditorState.create(state),\n\t});\n\n\treturn editor;\n}\n\n\n\n",
      "cursor": 5456,
      "active": false,
      "focus": false
    },
    {
      "type": "code",
      "id": "geuvga",
      "start": 32031,
      "focused": false,
      "output": "\nconst createTheme = ({ variant, settings, styles }) => {\n\tconst theme = EditorView.theme(\n\t\t{\n\t\t\t// eslint-disable-next-line @typescript-eslint/naming-convention\n\t\t\t\"&\": {\n\t\t\t\tbackgroundColor: settings.background,\n\t\t\t\tcolor: settings.foreground,\n\t\t\t},\n\t\t\t\".cm-editor.cm-focused\": {\n\t\t\t\toutline: \"none\",\n\t\t\t},\n\t\t\t\".cm-content\": {\n\t\t\t\tcaretColor: settings.caret,\n\t\t\t},\n\t\t\t\".cm-cursor, .cm-dropCursor\": {\n\t\t\t\tborderLeft: \"2px solid\" + settings.caret,\n\t\t\t},\n\t\t\t\"&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection\":\n\t\t\t{\n\t\t\t\tbackgroundColor: settings.selection,\n\t\t\t},\n\t\t\t\".cm-activeLine\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t\t\".cm-gutters\": {\n\t\t\t\tbackgroundColor: settings.gutterBackground,\n\t\t\t\tcolor: settings.gutterForeground,\n\t\t\t},\n            \"&.cm-focused .cm-fat-cursor\": {\n              background: settings.caret,\n              \n            },\n\t\t\t\".cm-activeLineGutter\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdark: variant === \"dark\",\n\t\t},\n\t);\n\n\tconst highlightStyle = HighlightStyle.define(styles);\n\tconst extension = [theme, syntaxHighlighting(highlightStyle)];\n\n\treturn extension;\n};\n\nconst theme = createTheme({\n\tvariant: \"dark\",\n\tsettings: {\n\t\tbackground: BACKGROUND,\n\t\tforeground: \"black\",\n\t\tcaret: \"brown\",\n\t\tselection: \"#036dd626\",\n\t\tgutterBackground: \"#fcfcfc22\",\n\t\tgutterForeground: \"#8a919922\",\n\t\tlineHighlight: \"#8a919922\",\n\t},\n\tstyles: [\n\t\t{\n\t\t\ttag: t.comment,\n\t\t\tcolor: \"#00000044\",\n\t\t},\n\t\t{\n\t\t\ttag: t.string,\n\t\t\tcolor: \"green\",\n\t\t},\n\t\t{\n\t\t\ttag: t.regexp,\n\t\t\tcolor: \"#4cbf99\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.number, t.bool, t.null],\n\t\t\tcolor: \"aaf\",\n\t\t},\n\t\t{\n\t\t\ttag: t.variableName,\n\t\t\tcolor: \"black\",\n          background: \"white\"\n\t\t},\n\t\t{\n\t\t\ttag: [t.definitionKeyword, t.modifier],\n\t\t\tcolor: \"maroon\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.keyword, t.special(t.brace)],\n\t\t\tcolor: \"blue\",\n\t\t},\n\t\t{\n\t\t\ttag: t.operator,\n\t\t\tcolor: \"#466\",\n\t\t},\n\t\t{\n          tag: t.separator,\n          color: \"#5c6166\",\n          background: \"red\"\n\t\t},\n\t\t{\n          tag: t.punctuation,\n          background: \"yellow\",\n          color: \"red\"\n\t\t},\n\t\t{\n          tag: [t.definition(t.propertyName), t.function(t.variableName)],\n          color: \"white\",\n          background: \"#0000ff\",\n          borderRadius: \"10px\", \n          padding:\"1px 5px\"\n\t\t},\n\t\t{\n\t\t\ttag: [t.className, t.definition(t.typeName)],\n\t\t\tcolor: \"white\",\n\t\t\tbackground: \"red\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.tagName, t.typeName, t.self, t.labelName],\n\t\t\tcolor: \"#55b4d4\",\n\t\t},\n\t\t{\n\t\t\ttag: t.angleBracket,\n\t\t\tcolor: \"#55b4d480\",\n\t\t},\n\t\t{\n\t\t\ttag: t.attributeName,\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t],\n});\n\nrender(Root, document.body);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false
    },
    {
      "type": "load-component",
      "id": "40oxq5",
      "start": 34686,
      "path": "",
      "output": "",
      "active": false
    },
    {
      "type": "save-component",
      "id": "zri8um",
      "start": 34686,
      "path": "editor/five.json",
      "output": "",
      "active": true,
      "focus": false
    }
  ],
  "output": ""
}